> 推荐学习指数：⭐️️⭐️️

## 1\. 前言

Svelte 本质上是一个编译器。虽说是原理篇，但我们并不会讲 Svelte 的编译原理，即 Svelte 如何将 `.svelte`文件转为 AST 又如何生成最终的代码：

```typescript
// 伪代码

const source = fs.readFileSync("App.svelte");
// 将源码转为 AST
const ast = parse(source);
// 追踪引用和依赖
const component = new Component(ast);
// 创建代码区块和片段
const renderer =
  options.generate === "ssr" ? SSRRenderer(component) : DomRenderer(component);
// 生成代码
const { js, css } = renderer.render();
fs.writeFileSync("App.js", js);
fs.writeFileSync("App.css", css);
```

这对大家使用 Svelte 并无太大帮助，而且个人能力有限。所以我们干脆讲解编译后的代码运行原理，从中大家可以了解到 Svelte 的响应式奥秘。

我们先从最基础的代码开始说起。

## 2\. Hello World!

最基础的代码莫过于 `"Hello World!"` 了：

```html
<h1>Hello world!</h1>
```

查看 [REPL 生成的代码](https://svelte.dev/repl/dadcfb1e41154db2a83e8c7a9ac99b9e?version=4.2.19 "https://svelte.dev/repl/dadcfb1e41154db2a83e8c7a9ac99b9e?version=4.2.19")：

```typescript
/* App.svelte generated by Svelte v4.2.19 */
import {
  SvelteComponent,
  detach,
  element,
  init,
  insert,
  noop,
  safe_not_equal,
} from "svelte/internal";

import "svelte/internal/disclose-version";

function create_fragment(ctx) {
  let h1;

  return {
    c() {
      h1 = element("h1");
      h1.textContent = "Hello world!";
    },
    m(target, anchor) {
      insert(target, h1, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(h1);
      }
    },
  };
}

class App extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment, safe_not_equal, {});
  }
}

export default App;
```

生成的代码主要有两部分：

1. `create_fragment`
2. `class App extends SvelteComponent`

其中，`create_fragment`负责生成代码片段，而且代码会随着左侧输入的代码改变而不断改变，而 `class App extends SvelteComponent`则负责导出类，实例化的时候会运行 `init`函数完成组件的初始化。

所以 `<h1>Hello world!</h1>`主要对应了这段代码：

```javascript
function create_fragment(ctx) {
  let h1;

  return {
    c() {
      h1 = element("h1");
      h1.textContent = "Hello world!";
    },
    m(target, anchor) {
      insert(target, h1, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(h1);
      }
    },
  };
}
```

`create_fragment`函数会返回一个包含多个函数的对象，其中：

1. `c`是 `create`的缩写，表示创建 DOM 片段
2. `m`是 `mount`的缩写，表示挂载 DOM
3. `p` 表示 `update`，表示更新 DOM（为啥不叫 `u`我也不知道……）
4. `i` 是 `intro` 的缩写，与入场动画相关
5. `o` 是 `outro` 的缩写，与退场动画相关
6. `d` 是 `destroy`的缩写，表示销毁 DOM

之所以使用缩写是因为代码压缩的时候，对象属性并不会被压缩，所以使用缩写，代码量会更小。

其中还涉及 `element` 和 `insert`两个函数，源码其实很简单：

```javascript
function element(name) {
  return document.createElement(name);
}

function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
```

也就是将 DOM 操作改为函数形式而已。

`class App extends SvelteComponent` 则负责组件的导出和初始化。最后我们会 `export default App`，所以每个组件都是一个类，这也就是为什么我们可以通过 `import Button from './button.svelte'`的方式导入其他 `svelte`组件。

让我们说下 `init` 函数，`init`函数是 Svelte 组件完成初始化的函数，它会：

1. 传入组件属性、上下文等
2. 写入组件生命周期事件
3. 绑定事件，并建立组件的更新机制
4. 调用 `create_fragment`创建元素并挂载到 DOM 上
5. ...

输出的代码中并没有 `init`函数的源码，所以仅靠输出的代码无法直接运行，不过我提供一个极简版的可运行代码，大家可以从中看到大致的执行过程。新建 `index.html`，代码如下：

```html
<html>
  <head>
    <title>svelte-under-the-hood</title>
  </head>
  <body>
    <div id="app"></div>
    <script src="./svelte.js"></script>
  </body>
</html>
```

新建 `svelte.js`，代码如下：

```javascript
function element(name) {
  return document.createElement(name);
}

function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}

function noop() {}

function safe_not_equal(a, b) {
  return a != a
    ? b == b
    : a !== b || (a && typeof a === "object") || typeof a === "function";
}

function mount_component(component, target, anchor) {
  const { fragment } = component.$$;
  fragment && fragment.m(target, anchor);
}

function init(
  component,
  options,
  instance,
  create_fragment,
  not_equal,
  props,
  append_styles = null,
  dirty = [-1]
) {
  const $$ = (component.$$ = {
    fragment: null,
    ctx: [],
    // state
    props,
    update: noop,
    not_equal,
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || []),
    dirty,
    skip_bound: false,
    root: options.target,
  });

  $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
  $$.fragment && $$.fragment.c();
  mount_component(component, options.target, options.anchor);
}

function create_fragment(ctx) {
  let h1;

  return {
    c() {
      h1 = element("h1");
      h1.textContent = "Hello world!";
    },
    m(target, anchor) {
      insert(target, h1, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(h1);
      }
    },
  };
}

class SvelteComponent {}

class App extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment, safe_not_equal, {});
  }
}

new App({
  target: document.getElementById("app"),
});
```

浏览器效果如下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a3e5bcb0ee14269b035ab705c81577e~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.jpg#?w=1450&h=294&s=39564&e=png&b=fefefe)

## 3\. 变量

假如现在使用了变量呢？现在代码改为：

```xml
<script>
  let name = 'world';
</script>

<h1>Hello {name}!</h1>
```

让我们看看 [REPL 的变化](https://svelte.dev/repl/hello-world?version=4.2.19 "https://svelte.dev/repl/hello-world?version=4.2.19")：

```javascript
// ...

function create_fragment(ctx) {
  let h1;

  return {
    c() {
      h1 = element("h1");
      h1.textContent = `Hello ${name}!`;
    },
    // ...
  };
}

let name = "world";

class App extends SvelteComponent {
  // ...
}

export default App;
```

可以看到，我们将 `<script>`中的代码移动到了代码最外层。而 `h1` 的 `textContent`使用了模板字符串。

## 4\. 更新变量

假设我们现在要更新变量呢？代码改为：

```xml
<script>
  let name = 'World';
  function update() {
    name = 'Svelte';
  }
</script>
<h1 on:click={update}>Hello {name}</h1>
```

查看 [REPL 的变化](https://svelte.dev/repl/cb8b2da019d748e3b7020a50c80ac15d?version=4.2.19 "https://svelte.dev/repl/cb8b2da019d748e3b7020a50c80ac15d?version=4.2.19")，可以看到代码发生了不少变化：

```javascript
// ...

function create_fragment(ctx) {
  let h1;
  let t0;
  let t1;
  let mounted;
  let dispose;

  return {
    c() {
      h1 = element("h1");
      t0 = text("Hello ");
      t1 = text(/*name*/ ctx[0]);
    },
    m(target, anchor) {
      insert(target, h1, anchor);
      append(h1, t0);
      append(h1, t1);

      if (!mounted) {
        dispose = listen(h1, "click", /*update*/ ctx[1]);
        mounted = true;
      }
    },
    p(ctx, [dirty]) {
      if (dirty & /*name*/ 1) set_data(t1, /*name*/ ctx[0]);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(h1);
      }

      mounted = false;
      dispose();
    },
  };
}

function instance($$self, $$props, $$invalidate) {
  let name = "World";

  function update() {
    $$invalidate(0, (name = "Svelte"));
  }

  return [name, update];
}

class App extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, {});
  }
}

export default App;
```

首先是我们将 `<script>`中的代码移到了 `instance` 函数中，之所以放在单独的函数中，是因为 Svelte 检测到变量可能会被更改，而我们要保证每个组件的变量更改都是独立的。

换句话说，在第二个例子中，`name` 的值是不变的，所以放在外面也没有什么关系，但在现在的例子中，`name` 的值是可能被更改的，所以需要放在单独的函数中：

```html
<App />
<App />
<App />

<!-- 组件的数据应该是独立的 -->
<h1>Hello World</h1>
<h1>Hello World</h1>
<h1>Hello Svelte</h1>
```

然后在 `instance()`函数中，我们将 `name` 和 `update` 以数组的形式进行了返回，在 Svelte 中，这个变量列表就是上下文（ctx），`create_fragment`函数执行时传入的 `ctx` 就是它：

```html
// 简化过程： // 执行 instance 函数，获取该组件的上下文 const ctx = instance();
// 传入上下文，获取片段 const fragment = create_fragment(ctx); // 创建 DOM
fragment.c(); // 挂载 DOM fragment.m(target);
```

再然后看 `create_fragment()`函数，我们不再直接获取变量，而是从 `ctx` 中获取变量的值：

```javascript
function create_fragment(ctx) {
  // ...
  return {
    c() {
      // ...
      t1 = text(/*name*/ ctx[0]);
    },
    m(target, anchor) {
      // ...
      if (!mounted) {
        dispose = listen(h1, "click", /*update*/ ctx[1]);
        mounted = true;
      }
    },
    p(ctx, [dirty]) {
      if (dirty & /*name*/ 1) set_data(t1, /*name*/ ctx[0]);
    },
    // ...
  };
}
```

这其中有 3 个新函数，`text`、`listen`和 `set_data`，其实源码都很简单：

```javascript
function text(data) {
  return document.createTextNode(data);
}

function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}

function set_data(text, data) {
  data = "" + data;
  if (text.data === data) return;
  text.data = data;
}
```

`set_data`看起来可能让人有些迷惑，但其实很简单，就是修改文本节点的意思。第一个参数是 `text`，是通过 `document.createTextNode` 创建的文本节点，第二个参数是 `data`，表示修改后的数据，`text.data = (data)`就是修改此文本节点的数据为新值。

当 mount 的时候，我们会调用：

```javascript
dispose = listen(h1, "click", /*update*/ ctx[1]);
```

`ctx[1]` 就是 `update`函数，由此我们完成事件绑定。

当点击的时候，触发 `update`函数，update 函数被编译为：

```javascript
function instance($$self, $$props, $$invalidate) {
  let name = "World";

  function update() {
    $$invalidate(0, (name = "Svelte"));
  }

  return [name, update];
}
```

那么 `$$invalidate` 是什么呢？这个函数其实可以在 `init` [函数的源码](https://github.com/sveltejs/svelte/blob/svelte%404.2.19/packages/svelte/src/runtime/internal/Component.js "https://github.com/sveltejs/svelte/blob/svelte%404.2.19/packages/svelte/src/runtime/internal/Component.js")中查看到：

```javascript
// 简略了部分代码：

function init(
  component,
  options,
  instance,
  create_fragment,
  not_equal,
  props,
  append_styles = null,
  dirty = [-1]
) {
  const $$ = (component.$$ = {
    fragment: null,
    ctx: [],
    // state
    props,
    update: noop,
    not_equal,
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || []),
    // everything else
    dirty,
    skip_bound: false,
    root: options.target,
  });

  let ready = false;
  $$.ctx = instance
    ? instance(component, options.props || {}, (i, ret, ...rest) => {
        const value = rest.length ? rest[0] : ret;
        if ($$.ctx && not_equal($$.ctx[i], ($$.ctx[i] = value))) {
          if (ready) make_dirty(component, i);
        }
        return ret;
      })
    : [];
  $$.update();
  ready = true;

  $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
  if (options.target) {
    $$.fragment && $$.fragment.c();
    mount_component(component, options.target, options.anchor);
    flush();
  }
}
```

其实就是我们调用 `instance` 函数传入的第三个参数，也就是这部分：

```javascript
(i, ret, ...rest) => {
  const value = rest.length ? rest[0] : ret;
  if ($$.ctx && not_equal($$.ctx[i], ($$.ctx[i] = value))) {
    if (ready) make_dirty(component, i);
  }
  return ret;
};
```

此时 `i`是 `0`，`ret`是 `name = 'Svelte'`，分析函数的执行内容，`value` 是 `'Svelte'`，`not_equal($$.ctx[i], ($$.ctx[i] = value))`用于判断之前的值和现在的值是否相同，不相同说明值发生了更改，此时 `ready`为 `true`，我们就会调用 `make_dirty(component, i)`，标记需要修改的组件和 `ctx` 的下标值。

函数名为 `make_dirty`，很多框架都用 `dirty` 来表示产生了变化的数据。翻译成“脏”，听起来稍微有些奇怪，习惯就好。

现在让我们看下 `make_dirty` [相关的源码](https://github.com/sveltejs/svelte/blob/svelte%404.2.19/packages/svelte/src/runtime/internal/Component.js#L78 "https://github.com/sveltejs/svelte/blob/svelte%404.2.19/packages/svelte/src/runtime/internal/Component.js#L78")：

```javascript
const dirty_components = [];

let update_scheduled = false;

function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}

function make_dirty(component, i) {
  // 组件是否已经“脏了”
  if (component.$$.dirty[0] === -1) {
    // 将组件放到需要“脏组件”数组中
    dirty_components.push(component);
    // 异步更新
    schedule_update();
    // 标记该组件已经“脏了”
    component.$$.dirty.fill(0);
  }
  // 标记该组件的脏数据的下标
  component.$$.dirty[(i / 31) | 0] |= 1 << i % 31;
}
```

这段代码并不算复杂，主要是判断该组件是否已经“脏了”，也就是有要改变的值。如果没有，将其放到 `dirty_components`中，然后再调用 `schedule_update()` 进行异步更新。这点类似于 React 的 setState，为了防止重复更新，采用异步的方式集中更新。

`component.$$.dirty[(i / 31) | 0] |= 1 << i % 31;`这句很简练，主要是借助了一种称为“位掩码”的技术，我们在下一篇文章中单独讲讲。

现在你只用知道，它的作用是将 `i`的值存储下来，用于知道上下文（ctx）中哪些下标值发生了变化，然后将其存放在该组件的 `$$.dirty` 属性中。

进入 `schedule_update()`函数代码：

```javascript
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
```

它主要是借助浏览器的微任务机制，执行 `flush`函数。我们再看下 `flush`的源码：

```javascript
let flushidx = 0;
function flush() {
  if (flushidx !== 0) {
    return;
  }

  while (flushidx < dirty_components.length) {
    const component = dirty_components[flushidx];
    flushidx++;

    update(component.$$);
  }

  dirty_components.length = 0;
  flushidx = 0;
}

function update($$) {
  if ($$.fragment !== null) {
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
  }
}
```

简单来说，就是遍历 `dirty_components`数组，执行组件的更新，最后执行 `create_fragment` 返回的 `p`函数：

```javascript
function create_fragment(ctx) {
  // ...

  return {
    // ...
    p(ctx, [dirty]) {
      if (dirty & /*name*/ 1) set_data(t1, /*name*/ ctx[0]);
    },
    // ...
  };
}
```

对于 `p` 函数，第一个参数时 `ctx`表示当前上下文，第二个参数时 `dirty`表示该组件需要更新的下标值，`if (dirty & /*name*/ 1)`则是为了判断当下下标值是否是 dirty 中需要更新的下标值，如果需要更新，则执行 `set_data`函数。

注：`if (dirty & /*name*/ 1)`这个判断我们也会在下篇详细讲解背后的原理。

由此 Svelte 实现了点击时的 DOM 更新操作。

当然此时你可能还是有些懵逼，没有关系，我直接提供一个可运行的版本，修改 `svelte.js` 的代码为：

```javascript
function element(name) {
  return document.createElement(name);
}

function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}

function text(data) {
  return document.createTextNode(data);
}

function append(target, node) {
  target.appendChild(node);
}

function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}

function noop() {}

function safe_not_equal(a, b) {
  return a != a
    ? b == b
    : a !== b || (a && typeof a === "object") || typeof a === "function";
}

function set_data(text, data) {
  data = "" + data;
  if (text.data === data) return;
  text.data = data;
}

const dirty_components = [];

const resolved_promise = /* @__PURE__ */ Promise.resolve();

let update_scheduled = false;

function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}

function make_dirty(component, i) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[(i / 31) | 0] |= 1 << i % 31;
}

let flushidx = 0;
function flush() {
  // Do not reenter flush while dirty components are updated, as this can
  // result in an infinite loop. Instead, let the inner flush handle it.
  // Reentrancy is ok afterwards for bindings etc.
  if (flushidx !== 0) {
    return;
  }

  while (flushidx < dirty_components.length) {
    const component = dirty_components[flushidx];
    flushidx++;

    update(component.$$);
  }

  dirty_components.length = 0;
  flushidx = 0;
}

function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    // run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    // $$.after_update.forEach(add_render_callback);
  }
}

function mount_component(component, target, anchor) {
  const { fragment } = component.$$;
  fragment && fragment.m(target, anchor);
}

function init(
  component,
  options,
  instance,
  create_fragment,
  not_equal,
  props,
  append_styles = null,
  dirty = [-1]
) {
  const $$ = (component.$$ = {
    fragment: null,
    ctx: [],
    // state
    props,
    update: noop,
    not_equal,
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || []),
    // everything else
    dirty,
    skip_bound: false,
    root: options.target,
  });

  let ready = false;
  $$.ctx = instance
    ? instance(component, options.props || {}, (i, ret, ...rest) => {
        const value = rest.length ? rest[0] : ret;
        if ($$.ctx && not_equal($$.ctx[i], ($$.ctx[i] = value))) {
          // if (!$$.skip_bound && $$.bound[i]) $$.bound[i](value);
          if (ready) make_dirty(component, i);
        }
        return ret;
      })
    : [];
  $$.update();
  ready = true;

  $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
  if (options.target) {
    $$.fragment && $$.fragment.c();
    mount_component(component, options.target, options.anchor);
    flush();
  }
}

function create_fragment(ctx) {
  let h1;
  let t0;
  let t1;
  let mounted;
  let dispose;

  return {
    c() {
      h1 = element("h1");
      t0 = text("Hello ");
      t1 = text(/*name*/ ctx[0]);
    },
    m(target, anchor) {
      insert(target, h1, anchor);
      append(h1, t0);
      append(h1, t1);

      if (!mounted) {
        dispose = listen(h1, "click", /*update*/ ctx[1]);
        mounted = true;
      }
    },
    p(ctx, [dirty]) {
      if (dirty & /*name*/ 1) set_data(t1, /*name*/ ctx[0]);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(h1);
      }

      mounted = false;
      dispose();
    },
  };
}

function instance($$self, $$props, $$invalidate) {
  let name = "World";

  function update() {
    $$invalidate(0, (name = "Svelte"));
  }

  return [name, update];
}

class SvelteComponent {}

class App extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, {});
  }
}

new App({
  target: document.getElementById("app"),
});
```

浏览器效果如下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94fd7b0484bf4bc292d10e953dc10ba2~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.gif#?w=740&h=155&s=10434&e=gif&f=9&b=fdfdfd)

大家可以通过调试这段可运行的代码，同时参照本篇文章的思路学习 Svelte 响应式实现方式。

## 5\. 最后

让我们回顾下整个流程，我们在 `.svelte`中写的代码，会对应编译成 `create_fragment`中的代码，它会返回一个包含 DOM 创建、挂载、更新、销毁等函数的对象。当组件实例化的时候，会调用 `init`函数，执行 DOM 的创建和挂载。

Svelte 之所以能够实现数据的响应式，是因为 Svelte 会判断变量是否被用到、是否会发生变化，然后将赋值操作语句编译成类似于 `$$invalidate(0, name = 'Svelte')`的代码。`0`表示该数据在上下文的下标值。而在 `$$invalidate`中，为了防止重复更新，Svelte 会先将需要更新的组件和下标值进行存储，然后统一执行更新。最后更新的时候，会进入到 `create_fragment` 返回的 DOM 更新函数，也就是 `p` 函数，在 `p`函数中，我们会判断数据是否需要更新，最后进行更新操作。

因为 Svelte 在编译的时候就建立了数据和 DOM 之间的映射关系，所以更新的时候，只用记录哪些数据发生了变化，然后进入了 `p`函数，通过 `if` 判断直接更新对应的 DOM 节点。这点不像 React 或者 Vue，需要通过 Virtual DOM 的 Diff 算法先算出哪些 DOM 节点需要更新，所以 Svelte 的 DOM 更新比 React、Vue 都更加高效。

但是因为 Svelte 会根据你的代码编译代码，过程中可能会产生很多冗余代码，所以 Svelte 尤其适合小型项目和追求高性能的项目。