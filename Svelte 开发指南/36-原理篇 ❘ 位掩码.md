> 推荐学习指数：⭐️️⭐️️

## 1\. 前言

上篇我们讲到 Svelte 的运行时源码中有这样一句代码：

```javascript
component.$$.dirty[(i / 31) | 0] |= 1 << i % 31;
```

它的作用是将 `i`值存储下来，从而知道上下文（ctx）中哪些下标值对应的变量发生了变化。

其实在更早的版本中，并没有这么“复杂”，不就是存储哪些值发生了变化吗？那就直接存储好了！举个例子：

```xml
<script>
  let name = 'World';
  function update() {
    name = 'Svelte';
  }
</script>

<h1 on:click={update}>Hello {name}</h1>
```

点击 `<h1>`的时候，`name` 值发生变化，那就将 `$$.dirty`存成：

```javascript
{
  name: true;
}
```

`name`变量发生了变化，然后异步更新，最后执行 `p()`函数：

```javascript
p($$.dirty, ctx) {
  if ($$.dirty.name) set_data(t1, ctx.name);
}
```

这样的代码看起来就直观很多。

但在 v3.16.0 后，Svelte 改成了现在的这种方式。这本质是一种叫做“**位掩码（bitmask）**”的技术。让我们举个简单的例子，来说明下“位掩码”：

假设现在有`[name1，name2，name3]` 三个值，我们需要知道哪些值发生了变化，为了节约存储空间，我们使用二进制来记录变化，其中 `0` 表示未发生变化，`1` 表示发生了变化。

`name1` 是数组的第 1 个值，我们用 `001`表示其发生了变化。`name2`是数组的第 2 个值，我们用 `010` 表示其发生了变化，`name3`是数组的第 3 个值，我们用 `100`表示其发生了变化。

如果`name1` 和 `name3` 都发生了变化呢？那就是 `101`，如果全发生了变化，那就是 `111`，如果都没发生变化，那就是 `000`。

最后我们将二进制转为十进制，比如二进制的 `111`就是 `7`，我们只用存储一个 `7`，就知道 `name1`、`name2`、`name3` 都发生了变化。

接下来我们讲解 `component.$$.dirty[(i / 31) | 0] |= 1 << i % 31`到底做了什么？但因为这其中涉及到一些位运算的知识，考虑到大家可能接触不多，我们先从最基本的位运算开始讲起。不过不用担心，我们倒不是要完整复习一遍位运算，我们只会讲到本篇用到的位运算知识。

## 2\. 按位或（|）

按位或（|）运算符在其中一个或两个操作数对应的二进制位为 1 时，该位的结果值为 1。举个例子：

```javascript
const a = 5; // 00000000000000000000000000000101
const b = 3; // 00000000000000000000000000000011

console.log(a | b); // 00000000000000000000000000000111
// 输出: 7
```

所以将任何整数 x 与 0 进行按位或运算得到 x，举个例子：

```javascript
const a = 5; // 00000000000000000000000000000101
const b = 0; // 00000000000000000000000000000000

console.log(a | b); // 00000000000000000000000000000101
// 输出: 5
```

那么问题来了，`(i / 31) | 0`的作用是啥呢？

答案是取整，我们可以在浏览器中试一下：

```javascript
// 0
(1 / 31) | 0
// 1
(33 / 31) | 0
// 2
( 63 / 31) | 0
```

那么问题来了，为什么要 `component.$$.dirty[(i / 31) | 0]`呢？

这是因为 JavaScript 进行二进制运算时，使用 32 位二进制整数，但还有一位要存放符号用于表示正负，所以只有 31 位可用于存储。这样最多就只能存储 31 个变量下标的变化。

那假设上下文返回了一个包含 100 个变量的数组呢？所以才需要使用数组形式，`component.$$.dirty[(i / 31) | 0] = xxx`，这样前 31 个变量下标（即数组的索引 0 到 30 的值）的变化存放到 `$$.dirty[0]`中，第 32 个 到 62 个的下标（即数组的索引 31 到 61）存放到 `$$.dirty[1]`中，依此类推。这样哪怕有 100 个变量，也只用存放 4 个整数就可以了。

## 3\. 取余（%）

取余（%）运算符返回左侧操作数除以右侧操作数的余数。它总是与被除数的符号保持一致。

这个符号想必大家已经很熟悉了，举个例子：

```javascript
console.log(13 % 5);
// 输出: 3

console.log(-13 % 5);
// 输出: -3

console.log(4 % 2);
// 输出: 0

console.log(-4 % 2);
// 输出: -0
```

## 4\. 左移 (<<)

左移操作符 (<<) 将第一个操作数向左移动指定位数，左边超出的位数将会被清除，右边将会补零。举个例子：

```javascript
const a = 5; // 00000000000000000000000000000101
const b = 2;

console.log(a << b); // 00000000000000000000000000010100
// 输出: 20
```

如果是 `1 << n`，假设 n 为 3，相当于：

```javascript
const a = 1; // 00000000000000000000000000000001
const b = 3;

console.log(a << b); // 00000000000000000000000000001000
// 输出: 8
```

前言中我们讲到，`[name1，name2，name3]` 三个值，`name1` 是数组的第 1 个值， 索引值为 `0`，我们用 `001`表示其发生了变化。`name2`是数组的第 2 个值，索引值为 `1`，我们用 `010` 表示其发生了变化，`name3`是数组的第 3 个值，索引值为 `2`，我们用 `100`表示其发生了变化。

那么问题来了，我们怎么从数组的下标值，换算成对应的二进制值呢？即如何从索引 `0` 转成 `001`，索引`1`转成 `010`，索引`2`转成 `100`呢？

这就是 `1 << n`实现的效果，`1 << 0`，结果为 `00000000000000000000000000000001`。`1 << 1`，结果为 `00000000000000000000000000000010`，`1 << 2`结果为 `00000000000000000000000000000100`。

而 `1 << i % 31`，相当于 `1 << (i % 31)`，也是相同的效果。之所以要 `i % 31` 是每次最多存储 31 个下标值，所以要通过取余获取当前的存放位置。

## 5\. 按位或赋值（|=）

按位或赋值（|=) 运算符使用两个操作数的二进制表示，对它们执行按位或运算并将结果分配给变量：

```javascript
x |= y; // x = x | y
```

所以：

```javascript
component.$$.dirty[(i / 31) | 0] |= 1 << i % 31;

// 相当于

component.$$.dirty[(i / 31) | 0] = component.$$.dirty[(i / 31) | 0] | (1 << i % 31);
```

而按位或（|）运算符在其中一个或两个操作数对应的二进制位为 1 时，该位的结果值为 1。

这样做是因为每次更新可能会有多个下标值需要记录，我们需要在之前记录的基础上再添加新的记录，而 `|`正好满足要求，因为 `1` 表示发生了变化，所以原本已经标记为 `1` ，`|` 之后结果依然为 1。原本为 `0`，遇到新的 `1`，则会记录下来。

所以最后让我们重新看下 `component.$$.dirty[(i / 31) | 0] |= 1 << i % 31`，它其实就是借助 JavaScript 的二进制计算，使用一个整数一次最多记录 31 个下标值是否发生了变化。

## 6\. 按位与（&）

按位与（&）运算符在两个操作数对应的二进位都为 1 时，该位的结果值才为 1。举个例子：

```javascript
const a = 5; // 00000000000000000000000000000101
const b = 3; // 00000000000000000000000000000011

console.log(a & b); // 00000000000000000000000000000001
// 输出: 1
```

简单来说，就是先将数字转为二进位，然后按位构造结果。

那你可能会想，这个有什么用呢？

我们可以用来判断当前值是否发生了变化。

依然以 `[name1, name2, name3]`这个数组为例，假设记录的结果为 `6`，转为二进制为 `110`，表示 `name2` 和 `name3` 发生了变化。现在我们要判断索引值为 `n`的值是否发生了变化，该怎么判断呢？

这个时候就需要 `&`。

我们以 `name1`为例，name1 的索引值为 `0`，`1 << 0` 对应的二进制为 `001`，对应十进制为 `1`，记录变化的结果为 `6`，也就是 `110`，我们就可以通过 `6 & 1`即 `110 & 001`来判断，此时结果为 `0`，表示没有变化。

假设记录变化的结果为 `7`，也就是 `111`，通过 `7 & 1`即 `111 & 001`来判断，此时结果为 `1`，表示发生了变化。

对于其他值也是类似的结果，只要结果不为 `0`，就表示发生了变化。

现在让我们看个例子：

```javascript
<script>
  let name1 = 'World';
  let name2 = 'World';
  let name3 = 'World';
  let name4 = 'World';
  let name5 = 'World';
  let name6 = 'World';
  let name7 = 'World';
  let name8 = 'World';
</script>

<button on:click={() => name1 = 'Svelte'}>Hello {name1}</button>
<button on:click={() => name2 = 'Svelte'}>Hello {name2}</button>
<button on:click={() => name3 = 'Svelte'}>Hello {name3}</button>
<button on:click={() => name4 = 'Svelte'}>Hello {name4}</button>
<button on:click={() => name5 = 'Svelte'}>Hello {name5}</button>
<button on:click={() => name6 = 'Svelte'}>Hello {name6}</button>
<button on:click={() => name7 = 'Svelte'}>Hello {name7}</button>
<button on:click={() => name8 = 'Svelte'}>Hello {name8}</button>
```

对应 [REPL 的输出结果](https://svelte.dev/repl/a5d6a2196da64993968e71f4791439a6?version=4.2.19 "https://svelte.dev/repl/a5d6a2196da64993968e71f4791439a6?version=4.2.19")为：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/77f1b22847c34b2b9e1272a3978dc7d6~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.jpg#?w=4266&h=992&s=523675&e=png&b=1f1f1f)

注意 `p(ctx, [dirty])`中的变化，`name1` 比较是 `dirty & 1`，`name4` 比较的是 `dirty & 8`，`name4` 为什么对应 8 呢？正是因为 `name4`在 `instance` 函数返回的数组中的索引值为 `3`，也就是数组的第 4 个元素，`1 << 3`，对应二进制 `1000`，转为十进制就是 `8`。

`name5` 对应 `16`，`name6` 对应 `32`……都是同样的计算逻辑。

而 `dirty` 正是计算的结果，通过 `dirty && n`，我们就可以算出当前索引值对应的变量是否发生了变化，如果发生了变化，则调用 `set_data`更新数据。

所以可以看出，Svelte 其实在 `p` 函数中就计算出了数据和 DOM 之间的映射关系，通过简单的位运算就可以算出当前数据是否发生了变化，然后直接更新 DOM，算是一个十分巧妙的实现。