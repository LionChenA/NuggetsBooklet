> 推荐学习指数：⭐️️⭐️️

## 1\. 前言

Svelte 5 之于 Svelte 4，并不是在 Svelte 4 上新增了一个符文功能，而是框架层面的彻底重写。

在 Svelte 4 中：

```xml
<script>
  let name = 'World';
  function update() {
    name = 'Svelte';
  }
</script>
<button on:click={update}>Hello {name}</button>
```

[代码被编译为](https://svelte.dev/repl/7c13473a03164ef8b4ee0caabda57cc1?version=4.2.19 "https://svelte.dev/repl/7c13473a03164ef8b4ee0caabda57cc1?version=4.2.19")：

```javascript
/* App.svelte generated by Svelte v4.2.19 */
import {
  SvelteComponent,
  append,
  detach,
  element,
  init,
  insert,
  listen,
  noop,
  safe_not_equal,
  set_data,
  text
} from "svelte/internal";

import "svelte/internal/disclose-version";

function create_fragment(ctx) {
  let button;
  let t0;
  let t1;
  let mounted;
  let dispose;

  return {
    c() {
      button = element("button");
      t0 = text("Hello ");
      t1 = text(/*name*/ ctx[0]);
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, t0);
      append(button, t1);

      if (!mounted) {
        dispose = listen(button, "click", /*update*/ ctx[1]);
        mounted = true;
      }
    },
    p(ctx, [dirty]) {
      if (dirty & /*name*/ 1) set_data(t1, /*name*/ ctx[0]);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(button);
      }

      mounted = false;
      dispose();
    }
  };
}

function instance($$self, $$props, $$invalidate) {
  let name = 'World';

  function update() {
    $$invalidate(0, name = 'Svelte');
  }

  return [name, update];
}

class App extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, {});
  }
}

export default App;
```

而在 Svelte 5 中，[相同的代码被编译为](https://svelte-5-preview.vercel.app/#H4sIAAAAAAAAEz2MsQrDIBRFf0XekhYC2a0JdOveIUPtkOoLSI2KPgtF_PdiQzvew7mnwGosJuC3Am7ZEDicQ4Ae6B3aSC-0hNBD8jmqRkRS0QSapJNkkVh7sZF1s49Wd6eG1-wUGe9YDnohPBxZaVjSz71-q7tcpRPDvykemcg75h1X1qjnWPZGnS5orWelJaoYdm2CHjavzWpQA6eYsd7rB99pKTPTAAAA "https://svelte-5-preview.vercel.app/#H4sIAAAAAAAAEz2MsQrDIBRFf0XekhYC2a0JdOveIUPtkOoLSI2KPgtF_PdiQzvew7mnwGosJuC3Am7ZEDicQ4Ae6B3aSC-0hNBD8jmqRkRS0QSapJNkkVh7sZF1s49Wd6eG1-wUGe9YDnohPBxZaVjSz71-q7tcpRPDvykemcg75h1X1qjnWPZGnS5orWelJaoYdm2CHjavzWpQA6eYsd7rB99pKTPTAAAA")：

```javascript
import * as $ from "svelte/internal/client";

var root = $.template(`<button> </button>`);

export default function App($$anchor) {
  let name = $.mutable_state('World');

  function update() {
    $.set(name, 'Svelte');
  }

  var button = root();
  var text = $.child(button);

  $.reset(button);
  $.template_effect(() => $.set_text(text, `Hello ${$.get(name) ?? ""}`));
  $.event("click", button, update);
  $.append($$anchor, button);
}
```

你会发现，编译输出的代码已经完全不一样了！`$.template`、`$.set`、`$.get`、`$.mutable_state`、`$.template_effect` 这些是什么意思？如果你查看这些函数的源码，你会发现有复杂的判断和绕来绕去的逻辑，光看代码实在是难以清楚知道实际运行时的逻辑。

那么我们有办法可以调试 Svelte 5 的运行时源码吗？这就是本篇要解决的问题。跟着本篇的步骤走，你可以很轻松的在 Svlete 5 运行时源码中打出断点，调试代码。

那就让我们开始吧。

## 2\. 下载源码

新建一个文件夹（叫啥都行）：

```xml
mkdir svelte-demo
```

新建 `index.html`，代码如下：

```xml
<html>
  <head>
    <title>svelte-demo</title>
  </head>
  <body>
    <script src="./svelte.js" type="module"></script>
  </body>
</html>
```

新建 `svelte.js`，我们从 [Svelte 5 Preview](https://svelte-5-preview.vercel.app/ "https://svelte-5-preview.vercel.app/") 中拷贝编译后的代码。

假设我们想要调试的源码是：

```xml
<script>
  let name = $state('World');
  function update() {
    name = 'Svelte';
  }
</script>
<button onclick={update}>Hello {name}</button>
```

可以看到右侧输出的代码为：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e05ca3e9b2364d1db195c366c68f2017~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.jpg#?w=4002&h=1292&s=391359&e=png&b=202020)

我们将输出的代码拷贝到 `svelte.js`中：

```xml
import * as $ from "svelte/internal/client";

function update(_, name) {
  $.set(name, 'Svelte');
}

var root = $.template(`<button> </button>`);

export default function App($$anchor) {
  let name = $.state('World');
  var button = root();

  button.__click = [update, name];

  var text = $.child(button);

  $.reset(button);
  $.template_effect(() => $.set_text(text, `Hello ${$.get(name) ?? ""}`));
  $.append($$anchor, button);
}

$.delegate(["click"]);
```

下载 Svelte 源码：

```xml
git clone git@github.com:sveltejs/svelte.git
```

此时的目录结构为：

```xml
svelte-demo
├─ svelte
├─ index.html
└─ svelte.js
```

## 3\. 修改引入

修改 `svelte.js`，将 `svelte/internal/client`改为引入 `svelte`的源码，并将组件挂载到 DOM 上：

```javascript
import * as $ from "./svelte/packages/svelte/src/internal/client/index.js";
import { mount } from "./svelte/packages/svelte/src/internal/client/render.js";

function update(_, name) {
  $.set(name, "Svelte");
}

var root = $.template(`<button> </button>`);

export default function App($$anchor) {
  let name = $.state("World");
  var button = root();

  button.__click = [update, name];

  var text = $.child(button);

  $.reset(button);
  $.template_effect(() => $.set_text(text, `Hello ${$.get(name) ?? ""}`));
  $.append($$anchor, button);
}

$.delegate(["click"]);

mount(App, {
  target: document.body,
});
```

如果我们直接在浏览器打开 index.html，此时会出现 CORS 错误：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f228b5e4b36e4b9594e7243cf309f65f~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.jpg#?w=2450&h=614&s=164297&e=png&b=2f2f2f)

这是因为我们设置了 `type="module"` 的缘故，所以我们在本地起一个服务。

最简单的方式就是使用 VSCode 插件 [Live Server](https://marketplace.visualstudio.com/items?itemName=ritwickdey.LiveServer "https://marketplace.visualstudio.com/items?itemName=ritwickdey.LiveServer")。安装后选择 `index.html`，右键选择使用 Live Server 打开：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05bf0806f4574510be1319b376b998e7~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.jpg#?w=1248&h=268&s=58377&e=png&b=262628)

此时资源成功加载：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7abdd828b86041aca12d9e65b5a8416a~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.jpg#?w=3140&h=1234&s=441665&e=png&b=2c2c2c)

当然因为源码有报错，所以页面还是空白。

但是没关系，接下来我们开始修复这些错误，保证源码能够正常运行。

## 4\. 修改源码

报错是因为引入了 `esm-env`导致的，可以在源码中看到这样的代码：

```javascript
import { DEV } from "esm-env";
```

最为简单的处理方式是直接替换源码：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3819397fe5934c049c38a66bdf81a716~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.jpg#?w=3294&h=510&s=198288&e=png&b=252525)

我们修改的是 `svelte/packages/svelte/src/internal`这个目录下的文件，所以直接在这个文件查找替换，将

```javascript
import { DEV } from "esm-env";
```

替换为：

```javascript
const DEV = false;
```

全部替换完后，发现还是有报错，这是因为还有一个文件使用了：

```javascript
import { BROWSER } from "esm-env";
```

我们再替换一次，将代码替换为:

```javascript
const BROWSER = true;
```

## 5\. 预览效果

此时我们再打开页面，发现已经可以正常运行：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/85900e957a4845478a31a391ff5785cc~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.gif#?w=1219&h=423&s=167155&e=gif&f=28&b=2a2a2a)

注：如果页面还是空白，有可能是被插件影响，建议使用**无痕模式**进行预览。

可以通过 VSCode 跳转源码查看：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f2b823a1995447ea8f278749f5a0ed5e~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.gif#?w=1219&h=423&s=286583&e=gif&f=35&b=1e1e1e)

## 6\. 调试源码

调试源码想必大家已经很熟了，在源码中打个 debugger，比如我想查看 $.set 的过程，就跳转 `set`函数的源码，打个 debugger：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6be304fa3f4f4b18aa76c12fb00df349~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.jpg#?w=2066&h=326&s=62023&e=png&b=1e1e1e)

当点击按钮，走到 `set`函数逻辑的时候就会触发：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e6a2b5b5f284a348325ce5883fa1c51~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.jpg#?w=2960&h=638&s=254669&e=png&b=2e2e2e)

然后使用这些按钮查看运行逻辑：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9bc36bac93634c50b4a3e052cfbe4fef~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.jpg#?w=1932&h=276&s=70639&e=png&b=2f2f2f)

这些按钮的意思正如图标所示：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bbf878d8a7064d58904b27a0e4e3c1aa~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.jpg#?w=72&h=62&s=4450&e=png&b=3d3d3d)：Resume Script Execution，继续执行脚本，此时会跳转到下一个断点

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4bbcadc072fd4e33bcdd0dcefa61bf48~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.jpg#?w=76&h=62&s=4568&e=png&b=3c3c3c)：Step over，用于跳过下一个函数调用，适用于在包含**与当前问题无关的函数**的代码行暂停时使用，此时会执行函数，但不进入此函数

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c8f1bdbf1c2844f396c09584cb0fc274~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.jpg#?w=76&h=62&s=4398&e=png&b=3d3d3d)：Step into，用于进入下一个函数调用，适用于在包含**与当前遇到的问题相关的函数**调用的代码行暂停时， ，此时会进入函数，用于调查该函数

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/592e17705e05400da3eeb053ec73d0df~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.jpg#?w=78&h=62&s=4407&e=png&b=3c3c3c)：Step out，当在与正在调试的问题无关的函数内暂停时，用于跳出函数代码

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d2a1cdb015344269afe230391fce8d6~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.jpg#?w=76&h=62&s=4417&e=png&b=3d3d3d)：Step，单步调试，类似于 Step into 也会进入函数

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/08097b6f11644b679672a69dafdc2348~tplv-k3u1fbpfcp-jj-mark:1600:0:0:0:q75.jpg#?w=78&h=60&s=4698&e=png&b=3c3c3c)：停用断点，有时不希望后续的断点再生效，就可以使用该按钮

小知识：Step 和 Step into 有什么区别呢？

主要在运行异步代码或多线程代码时有差异。

Step into：在遇到异步函数时，Step into 会进入函数

Step：会按照时间顺序跳过异步函数

举个例子：

```javascript
setTimeout(() => {
  console.log("inside");
}, 3000);

console.log("outside");
```

假设在第一行的断点处停止，Step into 会等待 3s 后进入第二行，Step 会进入第 4 行。

如果我们要调试查看源码的执行过程，Step 会更实用一些。